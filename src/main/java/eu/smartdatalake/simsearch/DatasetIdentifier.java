package eu.smartdatalake.simsearch;

import java.util.UUID;

/**
 * Provides identification for the attribute of a given dataset.
 */
public class DatasetIdentifier {

	String hashKey = null;
	private DataSource source;	// Either the directory of the CSV file or a JDBC connection
	private String dataset; 	// The name of the actual dataset, i.e., a CSV file or a database table
	int operation;				// The type of search operation (0: categorical_topk, 1: spatial_knn, 2: numerical_topk) supported by this data source
	String attrValue = null;
	String attrKey = null;
	private boolean queryable = true;   // Unless explicitly specified in the config, a dataset can be involved in similarity search queries 
	private String prefixURL = null;    // URL prefix to be combined with the values in attrKey (assuming this yields resolvable URLs)
	
	/**
	 * Constructor
	 * @param connection
	 * @param dataset
	 * @param colValueName
	 */
	public DatasetIdentifier(DataSource source, String dataset, String colValueName) {
		
		this.source = source;
		this.dataset = dataset;
		this.attrValue = colValueName;
		this.operation = -1;			//Initially, no operation has specified on this attribute		
		UUID uuid = generateUUID();    // Assign a UUID
		this.hashKey = uuid.toString();
	}
	
	/**
	 * Generates a (non-random) Universally Unique Dataset Identifier (UUID).
	 * @return  A 128-bit value that represents the UUID.
	 */
	private UUID generateUUID() {
		
		UUID uuid = null;
		//UUIDs generated by hashing over the connection and data source name and the attribute name
		try { 
		    byte[] bytes = (source + dataset + attrValue).getBytes("UTF-8"); 
			uuid = UUID.nameUUIDFromBytes(bytes);
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		return uuid;
	}
	
	/**
	 * Assign the name of the attribute (column) containing the searchable values.
	 * @param colName The column name to be assigned.
	 */
	public void setValueAttribute(String colName) {
		
		this.attrValue = colName;   // Applicable only if the input dataset has a header with column names
	}

	/**
	 * Assign the name of the attribute containing the identifiers of the searchable entities.
	 * @param colName The column name to be assigned.
	 */
	public void setKeyAttribute(String colName) {
		
		this.attrKey = colName;   // Applicable only if the input dataset has a header with column names
	}
	
	/**
	 * Assign the type of the search operation to the identifier.
	 * @param operation  An integer representing the type of the search operation (0: CATEGORICAL_TOPK; 1:SPATIAL_KNN ; 2:NUMERICAL_TOPK).
	 */
	public void setOperation(int operation) {
		this.operation = operation;
	}
	
	/**
	 * Assign a data source to the identifier.
	 * @param source  The data source providing the attribute values, either in-memory (CSV) or in-situ (JDBC).
	 */
	public void setDataSource(DataSource source) {
		this.source = source;
	}
	
	/**
	 * Specify that this attribute data will be involved or not in similarity search requests.
	 * @param queryable Boolean value: True, if this attribute may be specified in similarity search queries; otherwise, False.
	 */
	public void setQueryable(boolean queryable) {
		this.queryable = queryable;
	}

	/**
	 * Prefix to be used in composing URLs and issuing them as entity identifiers for similarity search results.
	 * @param prefixURL  The prefix to be added in the identifiers (coming from values in attrKey).
	 */
	public void setPrefixURL(String prefixURL) {
		this.prefixURL = prefixURL;
	}
	
	// GETTER methods
	
	public String getDatasetName() {
		return this.dataset;
	}
	
	public DataSource getDataSource() {
		return this.source;
	}
	
	public String getHashKey() {
		return this.hashKey;
	}
	
	public String getValueAttribute() {
		return this.attrValue;
	}

	public String getKeyAttribute() {
		return this.attrKey;
	}
	
	public int getOperation() {
		return operation;
	}

	public boolean isQueryable() {
		return queryable;
	}

	public String getPrefixURL() {
		return prefixURL;
	}

}
